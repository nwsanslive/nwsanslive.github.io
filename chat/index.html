<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat</title>
    <style>
        * {box-sizing:border-box;}
        body {background-color:#111111;color:#e0e0e0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;margin:0;padding:0;height:100dvh;display:flex;flex-direction:column;overflow:hidden;}
        #header {height:56px;background:#1e1e1e;display:flex;align-items:center;padding:0 16px;font-size:18px;font-weight:bold;border-bottom:1px solid #333;flex-shrink:0;}
        .status {text-align:center;padding:6px;font-size:13px;color:#aaa;flex-shrink:0;}
        #messages {flex:1 1 auto;overflow-y:auto;padding:15px;display:flex;flex-direction:column;gap:20px;-webkit-overflow-scrolling:touch;min-height:0;scroll-behavior:smooth;}

        .message-group {width: 100%;display: flex;flex-direction: column;align-items: center;}
        .timestamp {font-size:12px;color:#888;margin-bottom:8px;padding: 4px 12px;background: rgba(50,50,50,0.5);border-radius: 12px;}
        .message-wrapper {width: 100%;display: flex;flex-direction: column;}
        .message-container {display:flex;align-items:flex-end;gap:10px;max-width: min(85vw, 680px);width:fit-content;}
        .message-container.sent {margin-left:auto;justify-content:flex-end;flex-direction: row-reverse;}
        .message-container.received {margin-right:auto;justify-content:flex-start;flex-direction: row;}
        .message {max-width:100%;}
        .text-bubble {padding:11px 16px;border-radius:20px;word-break:break-word;position:relative;padding-bottom:24px;}
        .sent .text-bubble {background:#26b460;color:#ffffff;}
        .received .text-bubble {background:#2c2c2c;color:#e0e0e0;}
        .tick {position:absolute;bottom:6px;right:12px;font-size:13px;color:rgba(255,255,255,0.7);pointer-events:none;}
        .quote-bar {padding:8px 12px;background:rgba(0,0,0,0.3);border-left:4px solid #888;border-radius:8px;margin-bottom:8px;font-size:14px;color:#ccc;}
        .sent .quote-bar {border-left-color:#26b460;background:rgba(255,255,255,0.1);}
        .quote-role {font-weight:bold;}
        .media-img, .media-video, .media-audio {max-width:100%;height:auto;border-radius:12px;display:block;cursor:pointer;}
        .media-video, .media-audio {background:#000;max-width:320px;}
        .more-btn {width:36px;height:36px;border-radius:50%;background:rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font-size:20px;opacity:0;transition:opacity 0.2s;cursor:pointer;flex-shrink:0;}
        .message-container:hover .more-btn {opacity:1;}
        .file-info {margin-top:8px;font-size:14px;opacity:0.9;}
        .file-link {color:#5ebff9;text-decoration:underline;display:block;margin-top:4px;}

        /* Ê∂àÊÅØÂä®ÁîªÂçáÁ∫ßÔºöÂ∏¶ËΩªÂæÆÂºπÂá∫ÊïàÊûú */
        @keyframes messageFadeIn {
            0% {opacity:0;transform:translateY(30px) scale(0.9);}
            70% {opacity:1;transform:translateY(0) scale(1.03);}
            100% {opacity:1;transform:translateY(0) scale(1);}
        }
        .message-group.new-message {animation: messageFadeIn 0.5s ease-out forwards;}

        /* ËæìÂÖ•Âå∫Â∏ÉÂ±ÄË∞ÉÊï¥ */
        #input-area {
            flex-direction:column;
            flex-shrink:0;
            padding:8px 10px;
            background:#1e1e1e;
            padding-bottom:max(8px, env(safe-area-inset-bottom));
            position:relative;
        }
        .input-row {
            display:flex;
            align-items:flex-end;
            width:100%;
            gap:clamp(6px,2vw,10px);
        }
        #reply-preview {
            display:none;
            width:100%;
            padding:10px 12px;
            background:#2c2c2c;
            border-radius:12px;
            margin-bottom:8px;
            position:relative;
            font-size:14px;
            color:#ccc;
        }
        #cancel-reply {
            position:absolute;
            top:4px;
            right:8px;
            background:none;
            border:none;
            color:#aaa;
            font-size:24px;
            cursor:pointer;
        }
        #attach-button, #emoji-button, #voice-button, #send-button {
            height:clamp(36px,6vw,48px);
            min-height:36px;
            width:clamp(36px,6vw,48px);
            border-radius:50%;
            background:#26b460;
            color:#fff;
            border:none;
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            flex-shrink:0;
            font-size:20px;
        }
        #send-button {
            border-radius:12px;
            padding:0 clamp(16px,4vw,24px);
            font-weight:bold;
            font-size:clamp(14px,3.5vw,18px);
        }
        #message-input {
            flex:1;
            padding:11px 12px;
            border:none;
            border-radius:18px;
            background:#333333;
            color:#fff;
            resize:none;
            overflow:hidden;
            font-size:clamp(14px,3.5vw,18px);
            line-height:1.5;
            min-height:clamp(36px,6vw,48px);
            max-height:200px;
        }
        #message-input:focus {outline:none;}
        #message-input::-webkit-scrollbar {display:none;}

        /* Ë°®ÊÉÖÈù¢Êùø */
        #emoji-picker {
            display:none;
            position:absolute;
            bottom:calc(100% + 8px);
            left:10px;
            right:10px;
            background:#1e1e1e;
            border-radius:12px;
            padding:12px;
            box-shadow:0 -8px 30px rgba(0,0,0,0.6);
            max-height:250px;
            overflow-y:auto;
            grid-template-columns:repeat(8,1fr);
            gap:8px;
            z-index:100;
        }
        .emoji {
            font-size:28px;
            text-align:center;
            cursor:pointer;
            padding:4px;
            border-radius:8px;
        }
        .emoji:hover {background:#333;}

        #role-selection {flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;background:#1e1e1e;}
        #role-selection button {margin:15px;padding:14px 32px;font-size:18px;background:#26b460;color:#fff;border:none;border-radius:12px;cursor:pointer;}
        #file-input {display:none;}
        #fullscreen-overlay {display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.95);align-items:center;justify-content:center;z-index:9999;cursor:pointer;}
        #fullscreen-img {max-width:95%;max-height:95%;border-radius:8px;cursor:pointer;}
        #action-sheet {display:none;position:fixed;bottom:0;left:0;right:0;background:#1e1e1e;border-top-left-radius:16px;border-top-right-radius:16px;padding:20px 0;z-index:10000;flex-direction:column;}
        #action-sheet button {padding:16px 24px;font-size:17px;background:transparent;color:#e0e0e0;border:none;text-align:left;margin:0 20px;border-bottom:1px solid #333;}
        #action-sheet button:last-child {border-bottom:none;}
        #action-overlay {display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:9998;}

        @media (min-width: 900px) {
            #chat-container {max-width:900px;margin:20px auto;border-radius:12px;overflow:hidden;box-shadow:0 4px 30px rgba(0,0,0,0.6);height:calc(100dvh - 40px);}
            body {background:#0a0a0a;}
            #messages {padding:20px 40px;}
            #input-area {padding:12px 20px;}
        }
    </style>
</head>
<body>

    <div id="role-selection">
        <h1>Chat</h1>
        <p>ÈÄâÊã©‰Ω†ÁöÑË∫´‰ªΩ</p>
        <button id="role-didi">ÂºüÂºü</button>
        <button id="role-gege">Âì•Âì•</button>
    </div>

    <div id="chat-container" style="display:none;flex-direction:column;height:100dvh;">
        <div id="header">Chat</div>
        <div class="status" id="status">Ê≠£Âú®Âä†ËΩΩ...</div>
        <div id="messages"></div>
        <div id="input-area">
            <div id="reply-preview">
                <div id="reply-content"></div>
                <button id="cancel-reply">√ó</button>
            </div>
            <div class="input-row">
                <button id="attach-button" title="ÈôÑ‰ª∂">+</button>
                <button id="emoji-button">üòä</button>
                <button id="voice-button">üé§</button>
                <textarea id="message-input" placeholder="ËæìÂÖ•Ê∂àÊÅØ..." rows="1"></textarea>
                <button id="send-button">ÂèëÈÄÅ</button>
            </div>
            <input type="file" id="file-input" accept="*/*" multiple>
        </div>
        <div id="emoji-picker"></div>
    </div>

    <div id="fullscreen-overlay">
        <img id="fullscreen-img" src="" alt="ÂÖ®Â±èÊü•Áúã">
    </div>

    <div id="action-overlay"></div>
    <div id="action-sheet">
        <button id="action-reply">ÂõûÂ§ç</button>
        <button id="action-delete">Âà†Èô§</button>
        <button id="action-copy">Â§çÂà∂</button>
    </div>

    <script>
        const REPO = 'nwsanslive/nwsanslive.github.io';
        const HISTORY_PATH = 'chat/chat-history.json';
        const FILES_FOLDER = 'chat/files';
        const BRANCH = 'main';
        const HISTORY_API = `https://api.github.com/repos/${REPO}/contents/${HISTORY_PATH}`;

        const urlParams = new URLSearchParams(window.location.search);
        const GITHUB_TOKEN = urlParams.get('token');

        let currentRole = null;
        let lastTime = null;
        let selectedMessage = null;
        let replyTo = null;
        let lastHistoryLength = 0;
        let mediaRecorder = null;
        let audioChunks = [];

        const messagesDiv = document.getElementById('messages');
        const chatContainer = document.getElementById('chat-container');
        const roleSelection = document.getElementById('role-selection');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const attachButton = document.getElementById('attach-button');
        const emojiButton = document.getElementById('emoji-button');
        const voiceButton = document.getElementById('voice-button');
        const emojiPicker = document.getElementById('emoji-picker');
        const fileInput = document.getElementById('file-input');
        const statusDiv = document.getElementById('status');
        const fullscreenOverlay = document.getElementById('fullscreen-overlay');
        const fullscreenImg = document.getElementById('fullscreen-img');
        const actionOverlay = document.getElementById('action-overlay');
        const actionSheet = document.getElementById('action-sheet');
        const replyPreview = document.getElementById('reply-preview');
        const replyContent = document.getElementById('reply-content');
        const cancelReply = document.getElementById('cancel-reply');

        if (!GITHUB_TOKEN || !GITHUB_TOKEN.startsWith('ghp_')) {
            document.body.innerHTML = `<div style="padding:50px;text-align:center;color:#fff;"><h2>Áº∫Â∞ë Token</h2><p>ËØ∑‰ΩøÁî®Â∏¶ ?token= ÁöÑÈìæÊé•ËÆøÈóÆ</p></div>`;
            throw new Error("No token");
        }

        // Â∏∏Áî®Ë°®ÊÉÖÂàóË°®
        const emojis = ['üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','üòÇ','ü§£','ü•≤','üòä','üòá','üôÇ','üôÉ','üòâ','üòå','üòç','ü•∞','üòò','üòó','üòô','üòö','üòã','üòõ','üòù','üòú','ü§™','ü§®','üßê','ü§ì','üòé','ü•∏','ü§©','ü•≥','üòè','üòí','üòû','üòî','üòü','üòï','üôÅ','‚òπÔ∏è','üò£','üòñ','üò´','üò©','ü•∫','üò¢','üò≠','üò§','üò†','üò°','ü§¨','ü§Ø','üò≥','ü•µ','ü•∂','üò±','üò®','üò∞','üò•','üòì','ü§ó','ü§î','ü§≠','ü§´','ü§•','üò∂','üò¨','üôÑ','üòØ','üò¶','üòß','üòÆ','üò≤','ü•±','üò¥','ü§§','üò™','üòµ','ü§ê','ü•¥','ü§¢','ü§Æ','ü§ß','üò∑','ü§í','ü§ï','ü§ë','ü§†','üòà','üëø','üëπ','üë∫','ü§°','üí©','üëª','üíÄ','‚ò†Ô∏è','üëΩ','üëæ','ü§ñ','üéÉ','üò∫','üò∏','üòπ','üòª','üòº','üòΩ','üôÄ','üòø','üòæ','üëç','üëé','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û','ü§ü','ü§≤','üëã','ü§ö','üñêÔ∏è','‚úã','üññ','üëã','üí™','ü¶æ','ü´∂','‚ù§Ô∏è','üíõ','üíö','üíô','üíú','üñ§','ü§ç','üíî','‚ù£Ô∏è','üíï','üíû','üíì','üíó','üíñ','üíò','üíù','üèÉ','üíÉ','üï∫','üëØ','üè†','üåÉ','üå†','üéÜ','üéá','‚ú®','üåü','üí´'];

        function autoResize() {
            messageInput.style.height = 'auto';
            messageInput.style.height = `${messageInput.scrollHeight}px`;
        }

        function openFullscreen(url) {
            fullscreenImg.src = url;
            fullscreenOverlay.style.display = 'flex';
        }

        function closeFullscreen() {
            fullscreenOverlay.style.display = 'none';
            fullscreenImg.src = '';
        }

        fullscreenOverlay.addEventListener('click', closeFullscreen);
        fullscreenImg.addEventListener('click', (e) => e.stopPropagation());

        function formatTime(dateStr) {
            const d = new Date(dateStr);
            const month = d.getMonth() + 1;
            const date = d.getDate();
            const hour = d.getHours().toString().padStart(2, '0');
            const minute = d.getMinutes().toString().padStart(2, '0');
            return `${month}Êúà${date}Êó• ${hour}:${minute}`;
        }

        function shouldShowTimestamp(currentTime) {
            if (!lastTime) return true;
            const diff = (new Date(currentTime) - new Date(lastTime)) / 1000 / 60;
            return diff > 5;
        }

        function createMessageWrapper(item, isSeen = false) {
            const group = document.createElement('div');
            group.className = 'message-group';

            if (shouldShowTimestamp(item.time)) {
                const timeDiv = document.createElement('div');
                timeDiv.className = 'timestamp';
                timeDiv.textContent = formatTime(item.time);
                group.appendChild(timeDiv);
                lastTime = item.time;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';

            const container = document.createElement('div');
            container.className = item.role === currentRole ? 'message-container sent' : 'message-container received';

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';

            // ÂºïÁî®Êù°
            if (item.replyContent) {
                const quote = document.createElement('div');
                quote.className = 'quote-bar';
                quote.innerHTML = `<span class="quote-role">${item.replyRole}:</span> ${item.replyContent.replace(/\n/g, '<br>')}`;
                messageDiv.appendChild(quote);
            }

            // ÂÜÖÂÆπ
            if (item.type === 'text') {
                const bubble = document.createElement('div');
                bubble.className = 'text-bubble';
                bubble.innerHTML = item.content.replace(/\n/g, '<br>');
                if (item.role === currentRole) {
                    const tick = document.createElement('div');
                    tick.className = 'tick';
                    tick.textContent = isSeen ? '‚úì‚úì' : '‚úì';
                    bubble.appendChild(tick);
                }
                messageDiv.appendChild(bubble);
            } else if (item.type === 'image') {
                const img = document.createElement('img');
                img.src = item.url;
                img.className = 'media-img';
                img.addEventListener('click', () => openFullscreen(item.url));
                messageDiv.appendChild(img);
            } else if (item.type === 'video') {
                const video = document.createElement('video');
                video.src = item.url;
                video.controls = true;
                video.className = 'media-video';
                messageDiv.appendChild(video);
            } else if (item.type === 'audio') {
                const audio = document.createElement('audio');
                audio.src = item.url;
                audio.controls = true;
                audio.className = 'media-audio';
                messageDiv.appendChild(audio);
            } else {
                const bubble = document.createElement('div');
                bubble.className = 'text-bubble';
                const nameDiv = document.createElement('div');
                nameDiv.textContent = item.filename || 'Êñá‰ª∂';
                nameDiv.className = 'file-info';
                bubble.appendChild(nameDiv);
                const a = document.createElement('a');
                a.href = item.url;
                a.textContent = 'ÁÇπÂáª‰∏ãËΩΩ';
                a.className = 'file-link';
                a.target = '_blank';
                bubble.appendChild(a);
                messageDiv.appendChild(bubble);
            }

            const moreBtn = document.createElement('div');
            moreBtn.className = 'more-btn';
            moreBtn.textContent = '‚ãØ';
            moreBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectedMessage = {item, element: group};
                actionSheet.style.display = 'flex';
                actionOverlay.style.display = 'block';
            });

            container.appendChild(messageDiv);
            container.appendChild(moreBtn);
            wrapper.appendChild(container);
            group.appendChild(wrapper);
            return group;
        }

        function scrollToBottom() {
            messagesDiv.scrollTo({top: messagesDiv.scrollHeight, behavior: 'smooth'});
        }

        async function loadMessages(isInitial = false) {
            try {
                const res = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                let history = [];
                if (res.status === 404) {
                    await createEmptyHistory();
                    statusDiv.textContent = 'Êñ∞ËÅäÂ§©Â∑≤ÂºÄÂßã';
                    lastHistoryLength = 0;
                    messagesDiv.innerHTML = '';
                    if (isInitial) scrollToBottom();
                    return;
                }
                const data = await res.json();
                history = JSON.parse(decodeURIComponent(escape(atob(data.content))));

                const hasNew = history.length > lastHistoryLength;
                if (hasNew && document.hidden && Notification.permission === 'granted') {
                    const lastMsg = history[history.length - 1];
                    if (lastMsg.role !== currentRole) {
                        const body = lastMsg.type === 'text' ? lastMsg.content.slice(0, 50) + '...' : '[Â™í‰ΩìÊ∂àÊÅØ]';
                        new Notification(`Êñ∞Ê∂àÊÅØ - ${lastMsg.role}`, {body});
                    }
                }

                if (history.length !== lastHistoryLength || isInitial) {
                    messagesDiv.innerHTML = '';
                    lastTime = null;
                    history.forEach((item, index) => {
                        const isSeen = item.role === currentRole && index < history.length - 1;
                        const group = createMessageWrapper(item, isSeen);
                        messagesDiv.appendChild(group);
                    });
                    scrollToBottom();
                    lastHistoryLength = history.length;
                }
                statusDiv.textContent = 'ËÆ∞ÂΩïÂ∑≤ÂêåÊ≠•';
            } catch (e) {
                statusDiv.textContent = 'Âä†ËΩΩÂ§±Ë¥•';
                console.error(e);
            }
        }

        async function createEmptyHistory() {
            await fetch(HISTORY_API, {
                method: 'PUT',
                headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                body: JSON.stringify({message: 'init', content: btoa('[]'), branch: BRANCH})
            });
        }

        async function uploadFile(file) {
            const ext = file.name.split('.').pop() || '';
            const filename = Date.now() + '_' + Math.random().toString(36).substr(2, 9) + (ext ? '.' + ext : '');
            const path = `${FILES_FOLDER}/${filename}`;
            const url = `https://api.github.com/repos/${REPO}/contents/${path}`;

            const reader = new FileReader();
            const base64 = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });

            const res = await fetch(url, {
                method: 'PUT',
                headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                body: JSON.stringify({
                    message: `upload ${file.name}`,
                    content: base64,
                    branch: BRANCH
                })
            });

            if (!res.ok) throw new Error('‰∏ä‰º†Â§±Ë¥•');
            return {
                filename: file.name,
                url: `https://raw.githubusercontent.com/${REPO}/${BRANCH}/${path}`,
                path: path
            };
        }

        async function addToHistory(entry, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const getRes = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                    if (!getRes.ok) {
                        if (getRes.status === 404) {
                            await createEmptyHistory();
                        } else {
                            throw new Error('Ëé∑ÂèñÂéÜÂè≤Â§±Ë¥•');
                        }
                    }

                    const data = await getRes.json();
                    let history = data.content ? JSON.parse(decodeURIComponent(escape(atob(data.content)))) : [];
                    const currentSha = data.sha;

                    const newEntry = {
                        role: currentRole,
                        time: new Date().toISOString(),
                        ...entry
                    };

                    history.push(newEntry);

                    const putRes = await fetch(HISTORY_API, {
                        method: 'PUT',
                        headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                        body: JSON.stringify({
                            message: 'new message',
                            content: btoa(unescape(encodeURIComponent(JSON.stringify(history)))),
                            sha: currentSha,
                            branch: BRANCH
                        })
                    });

                    if (putRes.ok) return newEntry;
                    if (putRes.status === 409) continue;
                    throw new Error('ÂêåÊ≠•Â§±Ë¥•');
                } catch (e) {
                    if (i === retries - 1) throw e;
                }
            }
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text) return;

            statusDiv.textContent = 'Ê≠£Âú®ÂèëÈÄÅ...';

            try {
                const entry = {type: 'text', content: text};
                if (replyTo) {
                    entry.replyRole = replyTo.role;
                    entry.replyContent = replyTo.type === 'text' ? replyTo.content.slice(0, 120) : '[Â™í‰ΩìÊ∂àÊÅØ]';
                }

                const newEntry = await addToHistory(entry);

                const group = createMessageWrapper(newEntry, false);
                group.classList.add('new-message');
                messagesDiv.appendChild(group);
                scrollToBottom();
                lastHistoryLength++;

                messageInput.value = '';
                autoResize();
                replyTo = null;
                replyPreview.style.display = 'none';
                statusDiv.textContent = 'Â∑≤ÂèëÈÄÅ';
            } catch (e) {
                statusDiv.textContent = 'ÂèëÈÄÅÂ§±Ë¥•';
            }
        }

        async function sendFiles() {
            const files = fileInput.files;
            if (files.length === 0) return;

            let successCount = 0;
            for (let file of files) {
                statusDiv.textContent = `Ê≠£Âú®‰∏ä‰º† ${file.name}...`;
                try {
                    const uploaded = await uploadFile(file);
                    const type = file.type.startsWith('image/') ? 'image' :
                                 file.type.startsWith('video/') ? 'video' :
                                 file.type.startsWith('audio/') ? 'audio' : 'file';

                    const entry = {
                        type,
                        filename: uploaded.filename,
                        url: uploaded.url,
                        path: uploaded.path
                    };
                    if (replyTo) {
                        entry.replyRole = replyTo.role;
                        entry.replyContent = '[Â™í‰ΩìÊ∂àÊÅØ]';
                    }

                    const newEntry = await addToHistory(entry);

                    const group = createMessageWrapper(newEntry, false);
                    group.classList.add('new-message');
                    messagesDiv.appendChild(group);
                    scrollToBottom();
                    lastHistoryLength++;
                    successCount++;
                } catch (e) {
                    statusDiv.textContent = `${file.name} Â§±Ë¥•`;
                }
            }
            statusDiv.textContent = successCount === files.length ? 'ÊâÄÊúâÈôÑ‰ª∂Â∑≤ÂèëÈÄÅ' : 'ÈÉ®ÂàÜÂèëÈÄÅÂÆåÊàê';
            fileInput.value = '';
            replyTo = null;
            replyPreview.style.display = 'none';
        }

        // ËØ≠Èü≥ÂΩïÈü≥
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    const blob = new Blob(audioChunks, {type: 'audio/webm'});
                    const file = new File([blob], 'voice.webm', {type: 'audio/webm'});
                    statusDiv.textContent = 'Ê≠£Âú®‰∏ä‰º†ËØ≠Èü≥...';
                    try {
                        const uploaded = await uploadFile(file);
                        const entry = {
                            type: 'audio',
                            filename: 'ËØ≠Èü≥Ê∂àÊÅØ',
                            url: uploaded.url,
                            path: uploaded.path
                        };
                        if (replyTo) {
                            entry.replyRole = replyTo.role;
                            entry.replyContent = '[ËØ≠Èü≥Ê∂àÊÅØ]';
                        }
                        const newEntry = await addToHistory(entry);
                        const group = createMessageWrapper(newEntry, false);
                        group.classList.add('new-message');
                        messagesDiv.appendChild(group);
                        scrollToBottom();
                        lastHistoryLength++;
                        replyTo = null;
                        replyPreview.style.display = 'none';
                    } catch (e) {
                        statusDiv.textContent = 'ËØ≠Èü≥ÂèëÈÄÅÂ§±Ë¥•';
                    }
                    stream.getTracks().forEach(track => track.stop());
                };
                mediaRecorder.start();
                statusDiv.textContent = 'Ê≠£Âú®ÂΩïÈü≥... ÊùæÂºÄÂèëÈÄÅ';
            } catch (e) {
                statusDiv.textContent = 'È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù';
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
        }

        async function deleteMessage(item, retries = 3) {
            // ... (‰øùÊåÅÂéüÂà†Èô§ÈÄªËæë‰∏çÂèò)
            for (let i = 0; i < retries; i++) {
                try {
                    const getRes = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                    if (!getRes.ok) throw new Error('Ëé∑ÂèñÂéÜÂè≤Â§±Ë¥•');

                    const data = await getRes.json();
                    let history = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    const index = history.findIndex(h => h.time === item.time);
                    if (index === -1) return;

                    history.splice(index, 1);

                    const putRes = await fetch(HISTORY_API, {
                        method: 'PUT',
                        headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                        body: JSON.stringify({
                            message: 'delete message',
                            content: btoa(unescape(encodeURIComponent(JSON.stringify(history)))),
                            sha: data.sha,
                            branch: BRANCH
                        })
                    });

                    if (putRes.ok) {
                        if (item.type !== 'text' && item.path) await deleteFileFromGitHub(item.path);
                        return;
                    }
                    if (putRes.status === 409) continue;
                    throw new Error('Âà†Èô§Â§±Ë¥•');
                } catch (e) {
                    if (i === retries - 1) throw e;
                }
            }
        }

        async function deleteFileFromGitHub(path) {
            const deleteUrl = `https://api.github.com/repos/${REPO}/contents/${path}`;
            const getRes = await fetch(deleteUrl, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
            if (!getRes.ok) return;
            const data = await getRes.json();
            await fetch(deleteUrl, {
                method: 'DELETE',
                headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                body: JSON.stringify({message: 'delete file', sha: data.sha, branch: BRANCH})
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Âä®ÊÄÅÁîüÊàêË°®ÊÉÖ
            emojis.forEach(emoji => {
                const span = document.createElement('span');
                span.className = 'emoji';
                span.textContent = emoji;
                span.addEventListener('click', () => {
                    messageInput.value += emoji;
                    autoResize();
                    messageInput.focus();
                    emojiPicker.style.display = 'none';
                });
                emojiPicker.appendChild(span);
            });

            // ‰∫ã‰ª∂ÁªëÂÆö
            autoResize();
            messageInput.addEventListener('input', autoResize);

            document.getElementById('role-didi').addEventListener('click', () => selectRole('ÂºüÂºü'));
            document.getElementById('role-gege').addEventListener('click', () => selectRole('Âì•Âì•'));

            sendButton.addEventListener('click', sendMessage);
            attachButton.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', sendFiles);
            emojiButton.addEventListener('click', () => {
                emojiPicker.style.display = emojiPicker.style.display === 'grid' ? 'none' : 'grid';
            });

            // ËØ≠Èü≥ÈïøÊåâ
            voiceButton.addEventListener('mousedown', startRecording);
            voiceButton.addEventListener('touchstart', (e) => {e.preventDefault(); startRecording();});
            document.addEventListener('mouseup', stopRecording);
            document.addEventListener('touchend', stopRecording);

            // ÈîÆÁõòË°å‰∏∫ÔºàÊâãÊú∫Êç¢Ë°åÔºåÁîµËÑëEnterÂèëÈÄÅ/Ctrl+EnterÊç¢Ë°åÔºâ
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    if (!isMobile && !e.ctrlKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                }
            });

            messageInput.addEventListener('focus', () => setTimeout(scrollToBottom, 400));

            // Êìç‰ΩúË°®
            actionOverlay.addEventListener('click', () => {
                actionSheet.style.display = 'none';
                actionOverlay.style.display = 'none';
            });

            document.getElementById('action-copy').addEventListener('click', () => {
                if (selectedMessage && selectedMessage.item.type === 'text') {
                    navigator.clipboard.writeText(selectedMessage.item.content);
                }
                actionOverlay.click();
            });

            document.getElementById('action-reply').addEventListener('click', () => {
                if (selectedMessage) {
                    replyTo = selectedMessage.item;
                    replyPreview.style.display = 'block';
                    replyContent.innerHTML = `<strong>${replyTo.role}:</strong> ${replyTo.type === 'text' ? replyTo.content.replace(/\n/g, '<br>') : '[Â™í‰ΩìÊ∂àÊÅØ]'}`;
                    messageInput.focus();
                }
                actionOverlay.click();
            });

            cancelReply.addEventListener('click', () => {
                replyTo = null;
                replyPreview.style.display = 'none';
            });

            document.getElementById('action-delete').addEventListener('click', async () => {
                if (!selectedMessage || selectedMessage.item.role !== currentRole) {
                    actionOverlay.click();
                    return;
                }
                statusDiv.textContent = 'Ê≠£Âú®Âà†Èô§...';
                try {
                    await deleteMessage(selectedMessage.item);
                    await loadMessages(true);
                    statusDiv.textContent = 'Â∑≤Âà†Èô§';
                } catch (e) {
                    statusDiv.textContent = 'Âà†Èô§Â§±Ë¥•';
                    await loadMessages(true);
                }
                actionOverlay.click();
                selectedMessage = null;
            });
        });

        function selectRole(role) {
            currentRole = role;
            roleSelection.style.display = 'none';
            chatContainer.style.display = 'flex';
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
            loadMessages(true);
        }

        setInterval(() => { if (currentRole) loadMessages(); }, 2000);
    </script>
</body>
</html>
