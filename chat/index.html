<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat</title>
    <style>
        * {box-sizing:border-box;}
        body {background-color:#111111;color:#e0e0e0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;margin:0;padding:0;height:100dvh;display:flex;flex-direction:column;overflow:hidden;}
        #header {height:56px;background:#1e1e1e;display:flex;align-items:center;padding:0 16px;font-size:18px;font-weight:bold;border-bottom:1px solid #333;flex-shrink:0;}
        .status {text-align:center;padding:6px;font-size:13px;color:#aaa;flex-shrink:0;}
        #messages {flex:1 1 auto;overflow-y:auto;padding:15px;display:flex;flex-direction:column;gap:20px;-webkit-overflow-scrolling:touch;min-height:0;scroll-behavior:smooth;}

        .message-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .timestamp {
            font-size:12px;
            color:#888;
            margin-bottom:8px;
            padding: 4px 12px;
            background: rgba(50,50,50,0.5);
            border-radius: 12px;
        }
        .message-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        .message-container {
            display:flex;
            align-items:flex-end;
            gap:10px;
            max-width:85%;
            width:fit-content;
        }
        .message-container.sent {
            margin-left:auto;
            justify-content:flex-end;
            flex-direction: row-reverse;
        }
        .message-container.received {
            margin-right:auto;
            justify-content:flex-start;
            flex-direction: row;
        }
        .message {max-width:100%;}
        .text-bubble {padding:11px 16px;border-radius:20px;}
        .sent .text-bubble {background:#26b460;color:#ffffff;}
        .received .text-bubble {background:#2c2c2c;color:#e0e0e0;}
        .media-img, .media-video {max-width:100%;height:auto;border-radius:12px;display:block;cursor:pointer;}
        .media-video {background:#000;}
        .more-btn {width:36px;height:36px;border-radius:50%;background:rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font-size:20px;opacity:0;transition:opacity 0.2s;cursor:pointer;flex-shrink:0;}
        .message-container:hover .more-btn {opacity:1;}
        .file-info {margin-top:8px;font-size:14px;opacity:0.9;}
        .file-link {color:#5ebff9;text-decoration:underline;display:block;margin-top:4px;}

        @keyframes messageFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .message-group.new-message {
            animation: messageFadeIn 0.4s ease-out forwards;
        }

        /* 删除粒子动画 */
        @keyframes particleBurst {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--dx), var(--dy)) scale(0);
                opacity: 0;
            }
        }
        .particle {
            position: fixed;
            pointer-events: none;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: particleBurst 0.6s ease-out forwards;
            z-index: 9999;
        }

        #input-area {
            flex-shrink:0;
            display:flex;
            align-items:center;
            padding:8px 10px;
            background:#1e1e1e;
            padding-bottom:max(8px, env(safe-area-inset-bottom));
            gap: clamp(6px, 2vw, 10px);
            max-width: 100%;
        }
        #attach-button,
        #message-input,
        #send-button {
            height: clamp(36px, 6vw, 48px);
            font-size: clamp(14px, 3.5vw, 18px);
            min-height: 36px;
        }
        #attach-button {
            width: clamp(36px, 6vw, 48px);
            border-radius: 50%;
            background:#26b460;
            color:#fff;
            border:none;
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            flex-shrink:0;
        }
        #message-input {
            flex:1;
            padding:0 12px;
            border:none;
            border-radius:18px;
            background:#333333;
            color:#fff;
        }
        #message-input:focus {outline:none;}
        #send-button {
            padding:0 clamp(16px, 4vw, 24px);
            background:#26b460;
            color:#fff;
            border:none;
            border-radius:10px;
            cursor:pointer;
            font-weight:bold;
            flex-shrink:0;
            white-space: nowrap;
        }

        #role-selection {flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;background:#1e1e1e;}
        #role-selection button {margin:15px;padding:14px 32px;font-size:18px;background:#26b460;color:#fff;border:none;border-radius:12px;cursor:pointer;}
        #file-input {display:none;}

        /* 全屏图片放大/缩小动画 */
        #fullscreen-overlay {
            display:none;
            position:fixed;
            top:0;left:0;right:0;bottom:0;
            background:rgba(0,0,0,0.95);
            align-items:center;
            justify-content:center;
            z-index:9999;
            opacity:0;
            transition: opacity 0.3s ease;
        }
        #fullscreen-overlay.active {
            display:flex;
            opacity:1;
        }
        #fullscreen-img {
            max-width:95%;
            max-height:95%;
            cursor:pointer;
            border-radius:12px;
            transform: scale(0.8);
            opacity:0;
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.35s ease;
        }
        #fullscreen-overlay.active #fullscreen-img {
            transform: scale(1);
            opacity:1;
        }
        #fullscreen-overlay.closing #fullscreen-img {
            transform: scale(0.8);
            opacity:0;
        }

        #action-sheet {display:none;position:fixed;bottom:0;left:0;right:0;background:#1e1e1e;border-top-left-radius:16px;border-top-right-radius:16px;padding:20px 0;z-index:10000;flex-direction:column;}
        #action-sheet button {padding:16px 24px;font-size:17px;background:transparent;color:#e0e0e0;border:none;text-align:left;margin:0 20px;border-bottom:1px solid #333;}
        #action-sheet button:last-child {border-bottom:none;}
        #action-overlay {display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:9998;}
    </style>
</head>
<body>

    <div id="role-selection">
        <h1>Chat</h1>
        <p>选择你的身份</p>
        <button id="role-didi">弟弟</button>
        <button id="role-gege">哥哥</button>
    </div>

    <div id="chat-container" style="display:none;flex-direction:column;height:100dvh;">
        <div id="header">Chat</div>
        <div class="status" id="status">正在加载...</div>
        <div id="messages"></div>
        <div id="input-area">
            <button id="attach-button" title="添加附件">+</button>
            <input type="text" id="message-input" placeholder="输入消息...">
            <button id="send-button">发送</button>
            <input type="file" id="file-input" accept="*/*" multiple>
        </div>
    </div>

    <div id="fullscreen-overlay">
        <img id="fullscreen-img" src="" alt="全屏查看">
    </div>

    <div id="action-overlay"></div>
    <div id="action-sheet">
        <button id="action-reply">回复</button>
        <button id="action-delete">删除</button>
        <button id="action-copy">复制</button>
    </div>

    <script>
        const REPO = 'nwsanslive/nwsanslive.github.io';
        const HISTORY_PATH = 'chat/chat-history.json';
        const FILES_FOLDER = 'chat/files';
        const BRANCH = 'main';
        const HISTORY_API = `https://api.github.com/repos/${REPO}/contents/${HISTORY_PATH}`;

        const urlParams = new URLSearchParams(window.location.search);
        const GITHUB_TOKEN = urlParams.get('token');

        let currentRole = null;
        let lastTime = null;
        let selectedMessage = null;
        let lastHistoryLength = 0;

        const messagesDiv = document.getElementById('messages');
        const chatContainer = document.getElementById('chat-container');
        const roleSelection = document.getElementById('role-selection');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const attachButton = document.getElementById('attach-button');
        const fileInput = document.getElementById('file-input');
        const statusDiv = document.getElementById('status');
        const fullscreenOverlay = document.getElementById('fullscreen-overlay');
        const fullscreenImg = document.getElementById('fullscreen-img');
        const actionOverlay = document.getElementById('action-overlay');
        const actionSheet = document.getElementById('action-sheet');

        if (!GITHUB_TOKEN || !GITHUB_TOKEN.startsWith('ghp_')) {
            document.body.innerHTML = `<div style="padding:50px;text-align:center;color:#fff;"><h2>缺少 Token</h2><p>请使用带 ?token= 的链接访问</p></div>`;
            throw new Error("No token");
        }

        function openFullscreen(url) {
            fullscreenImg.src = url;
            fullscreenOverlay.classList.add('active');
            fullscreenOverlay.classList.remove('closing');
        }

        function closeFullscreen() {
            fullscreenOverlay.classList.add('closing');
            fullscreenOverlay.classList.remove('active');
            setTimeout(() => {
                fullscreenOverlay.style.display = 'none';
                fullscreenImg.src = '';
                fullscreenOverlay.classList.remove('closing');
            }, 350);
        }

        fullscreenOverlay.addEventListener('click', closeFullscreen);
        fullscreenImg.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        function formatTime(dateStr) {
            const d = new Date(dateStr);
            const month = d.getMonth() + 1;
            const date = d.getDate();
            const hour = d.getHours().toString().padStart(2, '0');
            const minute = d.getMinutes().toString().padStart(2, '0');
            return `${month}月${date}日 ${hour}:${minute}`;
        }

        function shouldShowTimestamp(currentTime) {
            if (!lastTime) return true;
            const diff = (new Date(currentTime) - new Date(lastTime)) / 1000 / 60;
            return diff > 5;
        }

        function createMessageWrapper(item) {
            const group = document.createElement('div');
            group.className = 'message-group';

            if (shouldShowTimestamp(item.time)) {
                const timeDiv = document.createElement('div');
                timeDiv.className = 'timestamp';
                timeDiv.textContent = formatTime(item.time);
                group.appendChild(timeDiv);
                lastTime = item.time;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';

            const container = document.createElement('div');
            container.className = item.role === currentRole ? 'message-container sent' : 'message-container received';

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';

            if (item.type === 'text') {
                const bubble = document.createElement('div');
                bubble.className = 'text-bubble';
                bubble.textContent = item.content || '';
                messageDiv.appendChild(bubble);
            } else if (item.type === 'image') {
                const img = document.createElement('img');
                img.src = item.url;
                img.className = 'media-img';
                img.addEventListener('click', () => openFullscreen(item.url));
                messageDiv.appendChild(img);
            } else if (item.type === 'video') {
                const video = document.createElement('video');
                video.src = item.url;
                video.controls = true;
                video.className = 'media-video';
                messageDiv.appendChild(video);
            } else {
                const bubble = document.createElement('div');
                bubble.className = 'text-bubble';
                const nameDiv = document.createElement('div');
                nameDiv.textContent = item.filename;
                nameDiv.className = 'file-info';
                bubble.appendChild(nameDiv);
                const a = document.createElement('a');
                a.href = item.url;
                a.textContent = '点击下载';
                a.className = 'file-link';
                a.target = '_blank';
                bubble.appendChild(a);
                messageDiv.appendChild(bubble);
            }

            const moreBtn = document.createElement('div');
            moreBtn.className = 'more-btn';
            moreBtn.textContent = '⋯';
            moreBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectedMessage = {item, element: group};
                actionSheet.style.display = 'flex';
                actionOverlay.style.display = 'block';
            });

            container.appendChild(messageDiv);
            container.appendChild(moreBtn);

            wrapper.appendChild(container);
            group.appendChild(wrapper);
            return group;
        }

        // 新增：粒子消失动画（类似 Telegram 删除效果）
        function createParticleBurst(element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2 + window.scrollX;
            const centerY = rect.top + rect.height / 2 + window.scrollY;

            const isSent = element.querySelector('.sent');
            const particleColor = isSent ? '#26b460' : '#ffffff'; // 发送绿色，接收白色

            for (let i = 0; i < 24; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.background = particleColor;

                const angle = Math.random() * Math.PI * 2;
                const velocity = 60 + Math.random() * 120;
                const dx = Math.cos(angle) * velocity;
                const dy = Math.sin(angle) * velocity;

                particle.style.setProperty('--dx', `${dx}px`);
                particle.style.setProperty('--dy', `${dy}px`);
                particle.style.left = `${centerX}px`;
                particle.style.top = `${centerY}px`;

                // 随机大小
                const size = 4 + Math.random() * 8;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;

                document.body.appendChild(particle);

                // 动画结束后自动移除
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 600);
            }
        }

        function scrollToBottom() {
            messagesDiv.scrollTo({
                top: messagesDiv.scrollHeight,
                behavior: 'smooth'
            });
        }

        async function loadMessages(isInitial = false) {
            try {
                const res = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                let history = [];
                if (res.status === 404) {
                    await createEmptyHistory();
                    statusDiv.textContent = '新聊天已开始';
                    lastHistoryLength = 0;
                    messagesDiv.innerHTML = '';
                    if (isInitial) scrollToBottom();
                    return;
                }
                const data = await res.json();
                history = JSON.parse(decodeURIComponent(escape(atob(data.content))));

                if (history.length !== lastHistoryLength || isInitial) {
                    messagesDiv.innerHTML = '';
                    lastTime = null;
                    history.forEach((item) => {
                        const group = createMessageWrapper(item);
                        messagesDiv.appendChild(group);
                    });
                    scrollToBottom();
                    lastHistoryLength = history.length;
                }
                statusDiv.textContent = '记录已同步';
            } catch (e) {
                statusDiv.textContent = '加载失败';
                console.error(e);
            }
        }

        async function createEmptyHistory() {
            await fetch(HISTORY_API, {
                method: 'PUT',
                headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                body: JSON.stringify({message: 'init', content: btoa('[]'), branch: BRANCH})
            });
        }

        async function uploadFile(file) {
            const ext = file.name.split('.').pop() || '';
            const filename = Date.now() + '_' + Math.random().toString(36).substr(2, 9) + (ext ? '.' + ext : '');
            const path = `${FILES_FOLDER}/${filename}`;
            const url = `https://api.github.com/repos/${REPO}/contents/${path}`;

            const reader = new FileReader();
            const base64 = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });

            const res = await fetch(url, {
                method: 'PUT',
                headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                body: JSON.stringify({
                    message: `upload ${file.name}`,
                    content: base64,
                    branch: BRANCH
                })
            });

            if (!res.ok) throw new Error('上传失败');
            return {
                filename: file.name,
                url: `https://raw.githubusercontent.com/${REPO}/${BRANCH}/${path}`,
                path: path
            };
        }

        async function addToHistory(entry, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const getRes = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                    if (!getRes.ok) {
                        if (getRes.status === 404) {
                            await createEmptyHistory();
                            getRes = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                            if (!getRes.ok) throw new Error('获取历史失败');
                        } else {
                            throw new Error('获取历史失败');
                        }
                    }

                    const data = await getRes.json();
                    let history = [];
                    if (data.content) {
                        history = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    }
                    const currentSha = data.sha;

                    const newEntry = {
                        role: currentRole,
                        time: new Date().toISOString(),
                        ...entry
                    };

                    history.push(newEntry);

                    const putRes = await fetch(HISTORY_API, {
                        method: 'PUT',
                        headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                        body: JSON.stringify({
                            message: 'new message',
                            content: btoa(unescape(encodeURIComponent(JSON.stringify(history)))),
                            sha: currentSha,
                            branch: BRANCH
                        })
                    });

                    if (putRes.ok) {
                        return newEntry;
                    }

                    if (putRes.status === 409) {
                        statusDiv.textContent = '检测到并发，正在重试...';
                        continue;
                    }

                    throw new Error('同步失败');
                } catch (e) {
                    console.error(e);
                    if (i === retries - 1) throw e;
                }
            }
            throw new Error('重试次数用尽');
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text) return;

            statusDiv.textContent = '正在发送...';

            try {
                const entry = {type: 'text', content: text};
                const newEntry = await addToHistory(entry);

                const group = createMessageWrapper(newEntry);
                group.classList.add('new-message');
                messagesDiv.appendChild(group);
                scrollToBottom();
                lastHistoryLength++;

                messageInput.value = '';
                statusDiv.textContent = '已发送';
            } catch (e) {
                console.error(e);
                statusDiv.textContent = '发送失败，请重试';
            }
        }

        async function sendFiles() {
            const files = fileInput.files;
            if (files.length === 0) return;

            let successCount = 0;

            for (let file of files) {
                statusDiv.textContent = `正在上传 ${file.name}...`;

                try {
                    const uploaded = await uploadFile(file);
                    const type = file.type.startsWith('image/') ? 'image' :
                                 file.type.startsWith('video/') ? 'video' : 'file';

                    const entry = {
                        type: type,
                        filename: uploaded.filename,
                        url: uploaded.url,
                        path: uploaded.path
                    };

                    const newEntry = await addToHistory(entry);

                    const group = createMessageWrapper(newEntry);
                    group.classList.add('new-message');
                    messagesDiv.appendChild(group);
                    scrollToBottom();
                    lastHistoryLength++;

                    successCount++;
                } catch (e) {
                    console.error(e);
                    statusDiv.textContent = `${file.name} 发送失败`;
                }
            }

            statusDiv.textContent = successCount === files.length ? '所有附件已发送' : '部分附件发送完成';
            fileInput.value = '';
        }

        async function deleteMessage(item, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const getRes = await fetch(HISTORY_API, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
                    if (!getRes.ok) throw new Error('获取历史失败');

                    const data = await getRes.json();
                    let history = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    const index = history.findIndex(h => h.time === item.time);
                    if (index === -1) return;

                    history.splice(index, 1);

                    const putRes = await fetch(HISTORY_API, {
                        method: 'PUT',
                        headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                        body: JSON.stringify({
                            message: 'delete message',
                            content: btoa(unescape(encodeURIComponent(JSON.stringify(history)))),
                            sha: data.sha,
                            branch: BRANCH
                        })
                    });

                    if (putRes.ok) {
                        if (item.type !== 'text' && item.path) {
                            await deleteFileFromGitHub(item.path);
                        }
                        return;
                    }

                    if (putRes.status === 409) {
                        statusDiv.textContent = '检测到并发，正在重试删除...';
                        continue;
                    }

                    throw new Error('删除同步失败');
                } catch (e) {
                    console.error(e);
                    if (i === retries - 1) throw e;
                }
            }
            throw new Error('删除重试次数用尽');
        }

        async function deleteFileFromGitHub(path) {
            const deleteUrl = `https://api.github.com/repos/${REPO}/contents/${path}`;
            const getRes = await fetch(deleteUrl, {headers: {'Authorization': `token ${GITHUB_TOKEN}`}});
            if (!getRes.ok) return;
            const data = await getRes.json();
            await fetch(deleteUrl, {
                method: 'DELETE',
                headers: {'Authorization': `token ${GITHUB_TOKEN}`, 'Accept': 'application/vnd.github.v3+json'},
                body: JSON.stringify({
                    message: 'delete file',
                    sha: data.sha,
                    branch: BRANCH
                })
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const actionReply = document.getElementById('action-reply');
            const actionDelete = document.getElementById('action-delete');
            const actionCopy = document.getElementById('action-copy');

            document.getElementById('role-didi').addEventListener('click', () => selectRole('弟弟'));
            document.getElementById('role-gege').addEventListener('click', () => selectRole('哥哥'));

            sendButton.addEventListener('click', sendMessage);
            attachButton.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', sendFiles);
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            messageInput.addEventListener('focus', () => setTimeout(scrollToBottom, 400));

            actionOverlay.addEventListener('click', () => {
                actionSheet.style.display = 'none';
                actionOverlay.style.display = 'none';
            });

            actionCopy.addEventListener('click', () => {
                if (selectedMessage && selectedMessage.item.type === 'text') {
                    navigator.clipboard.writeText(selectedMessage.item.content);
                }
                actionOverlay.click();
            });

            actionReply.addEventListener('click', () => {
                if (selectedMessage) {
                    messageInput.value = `回复 ${selectedMessage.item.role === currentRole ? '自己' : '对方'}: `;
                    messageInput.focus();
                }
                actionOverlay.click();
            });

            // 删除时添加粒子消失动画（类似 Telegram）
            actionDelete.addEventListener('click', async () => {
                if (!selectedMessage) return;

                const {item, element} = selectedMessage;

                if (item.role !== currentRole) {
                    actionOverlay.click();
                    return;
                }

                statusDiv.textContent = '正在删除...';

                try {
                    await deleteMessage(item);

                    // 触发粒子动画
                    createParticleBurst(element);

                    // 动画播放期间保持元素，结束后刷新列表
                    setTimeout(async () => {
                        await loadMessages(true);
                        statusDiv.textContent = '已删除';
                    }, 600);

                } catch (e) {
                    console.error('删除失败', e);
                    await loadMessages(true);
                    statusDiv.textContent = '删除失败，请重试';
                }

                actionOverlay.click();
                selectedMessage = null;
            });
        });

        function selectRole(role) {
            currentRole = role;
            roleSelection.style.display = 'none';
            chatContainer.style.display = 'flex';
            loadMessages(true);
        }

        setInterval(() => { if (currentRole) loadMessages(); }, 2000);
    </script>
</body>
</html>
